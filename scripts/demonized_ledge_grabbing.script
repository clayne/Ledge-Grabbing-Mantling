local gizmos = {
	sphereStart = nil,
	sphereEnd = nil,
	rayLines = {},
	pathLines = {},
	climbNormal = nil,
	sphereInter = nil,
	sphereActor = nil,
}

local savedClimbPos
local savedClimbNormal
local savedInterPos
local savedCollisionPos
local savedActorPos
local savedActorDir
local savedJumpPressedTime = math.huge
local savedCamY
local savedSpeed = vector():set(0,0,0)
local savedSpeedPos = vector():set(0,0,0)
local climbActive = false
local id = 69000
local idOffset = 0

-- Settings
local debugMode = false
maxClimbHeight = 2.5
minClimbHeight = 1.42

local drf = demonized_randomizing_functions
local dgr = demonized_geometry_ray

local soundPath = "ledge_grab"

-- Postpone on next n tick
local nextTick = _G.nextTick or function(f, n)
	n = math.floor(math.max(n or 1, 1))
	AddUniqueCall(function()
		if n == 1 then
			return f()
		else
			n = n - 1
			return false
		end
	end)
end

-- Linear inter/extrapolation
local function lerp(a, b, f)
    return a + f * (b - a)
end

local function vecLerp(v1, v2, f)
    return vector():set(
    	lerp(v1.x, v2.x, f),
    	lerp(v1.y, v2.y, f),
    	lerp(v1.z, v2.z, f)
    )
end

local function similar(a, b, eps)
	eps = eps or 0.00001
	return math.abs(a - b) < eps
end

local function vecSimilar(v1, v2, eps)
    return similar(v1.x, v2.x, eps) and similar(v1.y, v2.y, eps) and similar(v1.z, v2.z, eps)
end

local function cubicBezier(v1, v2, v3, v4, t)
	return vector():set(
		(1-t)^3*v1.x + 3*(1-t)^2*t*v2.x + 3*(1-t)*t^2*v3.x + t^3*v4.x,
		(1-t)^3*v1.y + 3*(1-t)^2*t*v2.y + 3*(1-t)*t^2*v3.y + t^3*v4.y,
		(1-t)^3*v1.z + 3*(1-t)^2*t*v2.z + 3*(1-t)*t^2*v3.z + t^3*v4.z
	)
end

local function cubicBezier2D(v1, v2, v3, v4, t)
	return vector():set(
		(1-t)^3*v1.x + 3*(1-t)^2*t*v2.x + 3*(1-t)*t^2*v3.x + t^3*v4.x,
		(1-t)^3*v1.y + 3*(1-t)^2*t*v2.y + 3*(1-t)*t^2*v3.y + t^3*v4.y,
		0
	)
end

local function mapRangeClamped(inVal, inMin, inMax, outMin, outMax)
	local k = math.min(1, normalize(inVal, inMin, inMax))
	return lerp(outMin, outMax, k)
end

local function array_keys(t, sorted, sort_func)
	local res = {}
	local res_count = 1
	for k, v in pairs(t) do
		res[res_count] = k
		res_count = res_count + 1
	end
	if sorted then
		if sort_func then
			table.sort(res, sort_func)
		else
			table.sort(res)
		end
	end
	return res
end

local function bisect_left(a, x, lo, hi)
	local lo = lo or 1
	local hi = hi or #a
	
	if lo < 0 then
		printf('bisect, lo must be non-negative')
		return
	end

	while lo < hi do
		local mid = math.floor((lo + hi) * 0.5)
		if a[mid] < x then 
			lo = mid+1
		else
			hi = mid
		end
    end

	return lo
end

local function lookup(t, key, tkeys)
	if is_empty(t) then return 0 end

	tkeys = tkeys or array_keys(t, true)

	local tkeys_len = #tkeys
	if #tkeys == 1 then return tkeys[1], tkeys[1], tkeys[1] end
	if key <= tkeys[1] then return tkeys[1], tkeys[1], tkeys[2] end
	if key >= tkeys[tkeys_len] then return tkeys[tkeys_len], tkeys[tkeys_len - 1], tkeys[tkeys_len] end

	local where = bisect_left(tkeys, key)
    local lo = tkeys[where-1] or tkeys[where]
    local hi = tkeys[where]
    if lo == hi then return lo, lo, lo end

    local delta = (key - lo) / (hi - lo)

    return delta, lo, hi
end


-- MCM
function load_defaults()
	local t = {}
	local op = demonized_ledge_grabbing_mcm.op
	for i, v in ipairs(op.gr) do
		if v.def ~= nil then
			t[v.id] = v.def
		end
	end
	return t
end

settings = load_defaults()

function load_settings()
	settings = load_defaults()
	if ui_mcm then
		for k, v in pairs(settings) do
			settings[k] = ui_mcm.get("demonized_ledge_grabbing/" .. k)
		end
	end
	return settings
end

function actor_on_first_update()
	savedActorPos = db.actor:position()
	savedActorDir = db.actor:direction()
	savedSpeedPos = db.actor:position()
	savedCamY = device().cam_pos.y - savedActorPos.y
	gizmos.sphereStart = debug_render.add_object(id + idOffset, DBG_ScriptObject.sphere):cast_dbg_sphere()
	idOffset = idOffset + 1

	gizmos.sphereEnd = debug_render.add_object(id + idOffset, DBG_ScriptObject.sphere):cast_dbg_sphere()
	idOffset = idOffset + 1

	gizmos.climbNormal = debug_render.add_object(id + idOffset, DBG_ScriptObject.line):cast_dbg_line()
	idOffset = idOffset + 1

	gizmos.sphereInter = debug_render.add_object(id + idOffset, DBG_ScriptObject.sphere):cast_dbg_sphere()
	idOffset = idOffset + 1

	gizmos.sphereActor = debug_render.add_object(id + idOffset, DBG_ScriptObject.sphere):cast_dbg_sphere()
	idOffset = idOffset + 1

	for i = 1, 20 do
		gizmos.pathLines[i] = debug_render.add_object(id + idOffset, DBG_ScriptObject.line):cast_dbg_line()
		idOffset = idOffset + 1
	end

	reset(nil, true)
	RegisterScriptCallback("actor_on_update", checkLedgeGrabbing)
	RegisterScriptCallback("actor_on_update", speedSaver)
end

function reset(gizmosArr, force)
	if debugMode or force then
		if gizmosArr then
			for i = 1, #gizmosArr do
				local gizmo = gizmosArr[i]
				if gizmos[gizmo] then
					local v = gizmos[gizmo]
					if type(v) == "table" then
						for i = 1, #v do
							local p = v[i]
							p.visible = false
						end
					else
						v.visible = false
					end
				end
			end
		else
			for k, v in pairs(gizmos) do
				if type(v) == "table" then
					for i = 1, #v do
						local p = v[i]
						p.visible = false
					end
				else
					v.visible = false
				end
			end		
		end
	end
	savedClimbPos = nil
end

function isWall(position, direction, targetAngle)
	targetAngle = targetAngle or 10
	local normal = dgr.get_surface_normal(
		position,
		direction
	)
	if not normal then return end

	local angle = math.abs(math.deg(math.asin(normal.y)))
    return angle < targetAngle, normal
end

function isFlat(position, direction, targetAngle)
	targetAngle = targetAngle or 23
	local normal = dgr.get_surface_normal(
		position,
		direction
	)
	if not normal then return end

	local angle = math.abs(math.deg(math.acos(normal.y)))
    return angle < targetAngle, normal
end

function getClimbPathEndPoints(actorPos, collisionPos, interPos, climbPos)
	local p1 = actorPos
	local p2 = vector():set(interPos.x, actorPos.y, interPos.z)
	local p3 = vector():set(
		lerp(actorPos.x, climbPos.x, 0.25),
		interPos.y,
		lerp(actorPos.z, climbPos.z, 0.25)
	)
	local p4 = climbPos
	return p1, p2, p3, p4
end

-- TODO: Fix to make it work with exactly (0, -1, 0)
function getDownVector()
	local d = device().cam_dir
	d.y = 0
	d:normalize()
	d.y = -100
	d:normalize()
	return d
end

function checkClimbPrecondition()
	-- Disable when on ladder
	if IsMoveState("mcClimb") then return false end
	return true
end

function speedSaver()
	local pos = db.actor:position()
	local speed = vector():set(pos):sub(savedSpeedPos):mul(1 / device().time_delta)
	savedSpeedPos = pos
	savedSpeed = speed
end

function checkLedgeGrabbing()
	if climbActive then return end
	if not settings.enable then return reset() end
	if not checkClimbPrecondition() then return reset() end
	local actorPos = vector():set(
		device().cam_pos.x,
		db.actor:position().y,
		device().cam_pos.z
	)
	local actorDir = device().cam_dir
	local realActorPos = db.actor:position()
	local realActorDir = db.actor:direction()
	if vecSimilar(realActorPos, savedActorPos, 0.02) and vecSimilar(realActorDir, savedActorDir, 0.02) then return end
	savedActorPos = realActorPos
	savedActorDir = realActorDir

	-- Check if player has possibility to initiate climb
	local collisionPos
	local collisionNormal
	local validCollisionPos = false
	local climbPos
	local climbNormal

	local pos = actorPos
	local maxY = actorPos.y + maxClimbHeight
	local minY = actorPos.y + minClimbHeight
	local rayRange = maxY - minY

	-- TODO: Fix to make it work with exactly (0, -1, 0)
	-- local dir = vector():set(0, -1, 0)
	local dir = getDownVector()

	local results = {
		[0] = {vector():set(actorPos.x, maxY, actorPos.z):mad(dir, rayRange), vector():set(dir):invert()}
	}

	-- Shoot rays in array from max climb height to min climb height
	-- Then check if found surface is flat
	-- If all succeeds - found a point to climb to
	-- Collision point will be the previous ray result from climb point, it will determine a wall
	local rayStepDistance = settings.climbTriggerDistance / settings.raySteps
	for j = 1, settings.raySteps do
		local i = rayStepDistance * j
		local ray = dgr.geometry_ray({
			ray_range = rayRange,
			flags = 2,
			ignore_object = db.actor
		})
		local pos = vector():mad(actorPos, actorDir, i)
		pos.y = maxY
		local res = ray:get(pos, dir)
		if res.success then
			local flat, normal = isFlat(pos, dir)
			if normal then
				if not collisionPos then
					collisionPos = results[j - 1][1]
					collisionNormal = results[j - 1][2]
				end

				if debugMode then
					if not gizmos.rayLines[j] then
						gizmos.rayLines[j] = debug_render.add_object(id + idOffset, DBG_ScriptObject.line):cast_dbg_line()
						idOffset = idOffset + 1
					end
					local p = gizmos.rayLines[j]
					p.visible = true
					p.color = fcolor():set(1,1,0,1)
				    p.point_a = pos
				    p.point_b = res.position
				end

				if flat then

					-- Player height check on climbPos
					-- If height is not enough - stop checking next position, assume that you cant move further
					local function posCheck(res)
						local ray = dgr.geometry_ray({
							ray_range = 1.4,
							flags = 2,
							ignore_object = db.actor
						})
						local heightRes = ray:get(res.position, vector():set(0,1,0))
						return not heightRes.success
					end

					local valid = posCheck(res)
					
					if debugMode then
						local p = gizmos.rayLines[j]
						p.color = valid and fcolor():set(0,1,0,1) or fcolor():set(1,0,0,1)
						for k = j + 1, #gizmos.rayLines do
							local x = gizmos.rayLines[k]
							x.visible = false
						end
					end

					validCollisionPos = valid
					climbPos = res.position
					climbNormal = normal

					if not validCollisionPos then break end

					-- Advance position a bit further and check it as well for better result
					-- If successfull - use that, otherwise use result
					local pos = vector():mad(actorPos, actorDir, i + 0.05)
					pos.y = maxY
					local res = ray:get(pos, dir)
					if res.success then
						local flat, normal = isFlat(pos, dir)
						if normal and flat then
							local valid = posCheck(res)
							if valid then
								climbPos = res.position
								climbNormal = normal
							end
						end
					end

					break
				end
			else
				if debugMode then
					if not gizmos.rayLines[j] then
						gizmos.rayLines[j] = debug_render.add_object(id + idOffset, DBG_ScriptObject.line):cast_dbg_line()
						idOffset = idOffset + 1
					end
					local p = gizmos.rayLines[j]
					p.visible = true
					p.color = fcolor():set(1,0,0,1)
				    p.point_a = pos
				    p.point_b = res.position
				end
				results[j] = {res.position, vector():set(dir):invert()}
			end
		else
			if debugMode then
				if not gizmos.rayLines[j] then
					gizmos.rayLines[j] = debug_render.add_object(id + idOffset, DBG_ScriptObject.line):cast_dbg_line()
					idOffset = idOffset + 1
				end
				local p = gizmos.rayLines[j]
				p.visible = true
				p.color = fcolor():set(1,0,0,1)
			    p.point_a = pos
			    p.point_b = vector():mad(pos, dir, rayRange)
			end
			collisionPos = nil
			collisionNormal = nil
			validCollisionPos = false
			results[j] = {vector():mad(pos, dir, rayRange), vector():set(dir):invert()}
		end
	end

	if not collisionPos then
		reset()
		return
	end

	-- Draw results
	if debugMode then
	    gizmos.sphereStart.visible = true
	    gizmos.sphereStart.color = fcolor():set(1,0,0,1)
	    local scale_mat = matrix():identity():scale(0.1,0.1,0.1)
	    local pos_mat = matrix():translate(collisionPos)
	    local mat = matrix():mul(pos_mat, scale_mat)
	    gizmos.sphereStart.matrix = mat
	end

	if not validCollisionPos then
		reset({"pathLines", "sphereEnd", "climbNormal", "sphereInter", "sphereActor"})
		return
	end

	if not climbPos then
		reset({"pathLines", "sphereEnd", "climbNormal", "sphereInter", "sphereActor"})
    	return
	end

    -- Compute climb path
    -- Interpos is point that will aid in climb path computing and used as a collision check in order to not climb through walls mostly
    local interPos = vector():set(
    	collisionPos.x,
    	climbPos.y + 0.15,
    	collisionPos.z
    )

    -- Don't init climb if points arent on the screen
    local climbPosUi = game.world2ui(climbPos)
    local interPosUi = game.world2ui(interPos)

    if not ((climbPosUi.x > 0 and climbPosUi.x < 1024 and climbPosUi.y > 0 and climbPosUi.y < 768) or (interPosUi.x > 0 and interPosUi.y < 1024 and interPosUi.y > 0 and interPosUi.y < 768)) then
    	reset({"pathLines", "sphereEnd", "climbNormal", "sphereInter", "sphereActor"})
    	return
    end

    if debugMode then
    	gizmos.sphereEnd.visible = true
	    gizmos.sphereEnd.color = fcolor():set(0,1,0,1)
	    local scale_mat = matrix():identity():scale(0.1,0.1,0.1)
	    local pos_mat = matrix():translate(climbPos)
	    local mat = matrix():mul(pos_mat, scale_mat)
	    gizmos.sphereEnd.matrix = mat

	    gizmos.climbNormal.visible = true
		gizmos.climbNormal.color = fcolor():set(0,1,0,1)
		gizmos.climbNormal.point_a = climbPos
		gizmos.climbNormal.point_b = vector():mad(climbPos, climbNormal, 1)

	    gizmos.sphereInter.visible = true
	    gizmos.sphereInter.color = fcolor():set(1,1,0,1)
	    local scale_mat = matrix():identity():scale(0.1,0.1,0.1)
	    local pos_mat = matrix():translate(interPos)
	    local mat = matrix():mul(pos_mat, scale_mat)
	    gizmos.sphereInter.matrix = mat
	    
	    gizmos.sphereActor.visible = true
	    gizmos.sphereActor.color = fcolor():set(1,0,0,1)
	    local scale_mat = matrix():identity():scale(0.1,0.1,0.1)
	    local pos_mat = matrix():translate(actorPos)
	    local mat = matrix():mul(pos_mat, scale_mat)
	    gizmos.sphereActor.matrix = mat
	end

    -- Collision check for climb path - ray cast to interPos
    local posToInterVec = vector():set(interPos):sub(actorPos)
    local collisionCheckRay = dgr.geometry_ray({
    	ray_range = posToInterVec:magnitude(),
		flags = 2,
		ignore_object = db.actor
    })
	local pos = actorPos
	local dir = vector():set(posToInterVec):normalize()
	local res = collisionCheckRay:get(pos, dir)
	local collisionCheck = res.distance == posToInterVec:magnitude()

	if debugMode then
	    local pathLinesNum = #gizmos.pathLines
	    local p1, p2, p3, p4 = getClimbPathEndPoints(actorPos, collisionPos, interPos, climbPos)
	    for i = 1, pathLinesNum do
	    	local k = (i / pathLinesNum) - (1 / pathLinesNum)
	    	local nextK = ((i+1) / pathLinesNum) - (1 / pathLinesNum)
	    	local p = gizmos.pathLines[i]
			p.visible = true
			p.color = collisionCheck and fcolor():set(0,1,0,1) or fcolor():set(1,0,0,1)
		    p.point_a = cubicBezier(p1, p2, p3, p4, k)
		    p.point_b = cubicBezier(p1, p2, p3, p4, nextK)
		end
	end

	if not collisionCheck then
		savedClimbPos = nil
		return
	end

	savedCollisionPos = collisionPos
    savedClimbPos = climbPos
    savedInterPos = interPos
    savedClimbNormal = climbNormal
end

-- Weight factor
-- Follows vanilla CoP behaviour (no penalty with less than 50% of weight)
-- The maxWeight is minumum 60 kg in order to give more stamina with starter equipment
function getActorWeights()
	local maxWeight = math.max(60, db.actor:get_actor_max_walk_weight())
	local minWeight = maxWeight / 2
	local weight = db.actor:get_total_weight()
	return weight, minWeight, maxWeight
end

-- Animation speed modifier
-- 33% speed reduction when player is at max weight
-- Full speed if weight is below half of max walk weight
-- Slight speed reduction at low stamina
function getAnimationSpeedModifier()
	local weight, minWeight, maxWeight = getActorWeights()
	local k = mapRangeClamped(weight, minWeight, maxWeight, 0, 0.33)
	k = 1 - k
	local staminaK = mapRangeClamped(db.actor.power, 0, 0.66, 0.87, 1)
	k = k * staminaK
	return k
end

-- Stamina drain modifier
function getStaminaDrain()
	local weight, minWeight, maxWeight = getActorWeights()
	local k = mapRangeClamped(weight, minWeight, maxWeight, 0.12, 0.72)
	return k
end

function getSatietyDrain()
	local weight, minWeight, maxWeight = getActorWeights()
	local k = mapRangeClamped(weight, minWeight, maxWeight, 0.001, 0.005)
	return k
end

-- Get modifier for prebaked camera rotations
function getRotationAnimModifier()
	return 0.5
end

function tryToClimb()
	if climbActive then return end
	if not savedClimbPos then return end

	-- Read animation data and set params
	local animationSpeed = 0.8 * getAnimationSpeedModifier()
	local animationData = dup_table(demonized_ledge_grabbing_animation_data.data)
	local startTime = time_global()
	local animationStartTime = 0
	local animationEndTime = animationData.calculatedTime
	local endTime = startTime + animationData.calculatedTime / animationSpeed * 1000 
	local animInTime = 26 / animationData.originalFps
	local animOutTime = 50 / animationData.originalFps

	-- Adjust hud motion
	local hudMotionSpeed = 0.78
	local hudMotionStarted = false	

	-- Get positions
	climbActive = true
	local climbPos = vector():set(savedClimbPos)
	local interPos = vector():set(savedInterPos)
	local collisionPos = vector():set(savedCollisionPos)
	local actorPos = db.actor:position()

	-- Get difference from camera height to position
	local camY = savedCamY

	-- make playerPos during climb so it will stay there during camera anim
	-- Adjust it to fit animation
	local playerPosOffset = 0.04
	local d = vector():set(collisionPos):sub(climbPos)
	d.y = 0
	d:normalize()
	local playerPos = vector():set(
		collisionPos.x,
		climbPos.y - camY,
		collisionPos.z
	) 
	playerPos:mad(d, playerPosOffset)

	-- Adjusted positions by difference from camera
	local adjustedClimbPos = vector():set(climbPos):add(vector():set(0, camY, 0))
	local adjustedInterPos = vector():set(interPos):add(vector():set(0, camY, 0))
	local adjustedCollisionPos = vector():set(collisionPos):add(vector():set(0, camY, 0))
	local adjustedActorPos = vector():set(actorPos):add(vector():set(0, camY, 0))

	local camDir = device().cam_dir
	local camDirHPB = vector():set(
		camDir:getH(),
		camDir:getP(),
		0
	)

	local p1, p2, p3, p4 = getClimbPathEndPoints(adjustedActorPos, adjustedCollisionPos, adjustedInterPos, adjustedClimbPos)

	-- Distance from collision point to camera for better hands display
	local startCameraDistance = 0.4

	-- Camera offset
	local startCameraOffset = vector():set(0, -0.5, 0)

	-- Camera offset when in animIn state
	local animInCameraOffset = vector():set(0, 0.1, 0)

	local d = vector():set(collisionPos):sub(climbPos)
	d.y = 0
	d:normalize()
	local p = vector():set(playerPos)
	p.y = p.y + camY
	local startCameraPos = vector():mad(p, d, startCameraDistance)
	startCameraPos:add(startCameraOffset)

	-- print_tip("playerPos %s \\n camY %s", playerPos, camY)

	-- Gameplay params
	local staminaDrain = getStaminaDrain()
	local staminaDrainPerMs = staminaDrain / (endTime - startTime)

	local satietyDrain = getSatietyDrain()
	local satietyDrainPerMs = satietyDrain / (endTime - startTime)

	-- Hide detector and weapon immediately (move to ruck works)
	local activeSlot = db.actor:active_slot()
	local activeWpn = db.actor:active_item()
	local activeDetector = db.actor:active_detector()
	local activeWpnId
	local activeDetectorId
	if activeWpn or activeDetector then
		if activeWpn then
			db.actor:move_to_ruck(activeWpn)
			activeWpnId = activeWpn:id()
		end
		if activeDetector then
			db.actor:move_to_ruck(activeDetector)
			activeDetectorId = activeDetector:id()
		end	
	end

	-- Uncrouch if was crouched
	if IsMoveState("mcCrouch") then
		if (get_console():get_bool("crouch_toggle")) then
			level.press_action(bind_to_dik(key_bindings.kCROUCH))
		else
			level.release_action(bind_to_dik(key_bindings.kCROUCH))
		end
	end

	-- game.only_allow_movekeys(true)
	game.set_actor_allow_ladder(false)

	-- 2 ticks required for hiding weapon forcefully with move to ruck for proper animation
	nextTick(function()
		local snd = xr_sound.get_safe_sound_object(soundPath)
		snd:play(db.actor, 0, sound_object.s2d)
		snd.frequency = getAnimationSpeedModifier()
		local k = 0
		local performClimb
		performClimb = function()
			-- If close to animation end - stop and give control to player
			if k > 0.98 then

				local p = cubicBezier(p1, p2, p3, p4, k)
				p.y = p.y - camY + 0.07 -- Small offset for better collision handling
				db.actor:set_actor_direction(-camDirHPB.x)
				db.actor:set_actor_position(p)
				level.remove_cam_custom_position_direction()
				game.stop_hud_motion()

				-- Restore weapons if had
				if activeWpnId or activeDetectorId then
					if activeWpnId then
						local obj = level.object_by_id(activeWpnId)
						if obj then
							db.actor:move_to_slot(obj, activeSlot)
							nextTick(function()
								db.actor:activate_slot(activeSlot)
								return true
							end, 2)
						end
					end
					if activeDetectorId then
						local obj = level.object_by_id(activeDetectorId)
						if obj then
							db.actor:move_to_slot(obj, 9)

							-- Time event for proper animation play
							CreateTimeEvent("ledge_grabbing", "activate_detector", 0.5, function()
								obj:switch_state(1)
								return true
							end)
						end
					end
				end

				-- game.only_allow_movekeys(false)
				game.set_actor_allow_ladder(true)

				-- Set flag after some time
				UnregisterScriptCallback("actor_on_update", performClimb)
				CreateTimeEvent("ledge_grabbing", "reset", 0.5, function()
					climbActive = false
					reset()
					return true
				end)
				return
			end

			local animTime = (time_global() - startTime) / 1000 * animationSpeed

			-- Get camera params from animation data					
			local locationX = animationData.curves.locationX
			local delta, lo, hi = lookup(locationX, animTime)
			local locationXRes = cubicBezier2D(locationX[lo][1], locationX[lo][2], locationX[lo][3], locationX[lo][4], delta)
			local animDelta, animLo, animHi = delta, lo, hi

			local locationY = animationData.curves.locationY
			local delta, lo, hi = lookup(locationY, animTime)
			local locationYRes = cubicBezier2D(locationY[lo][1], locationY[lo][2], locationY[lo][3], locationY[lo][4], delta)

			local locationZ = animationData.curves.locationZ
			local delta, lo, hi = lookup(locationZ, animTime)
			local locationZRes = cubicBezier2D(locationZ[lo][1], locationZ[lo][2], locationZ[lo][3], locationZ[lo][4], delta)

			local rotationX = animationData.curves.rotation_eulerX
			local delta, lo, hi = lookup(rotationX, animTime * hudMotionSpeed)
			local rotationXRes = cubicBezier2D(rotationX[lo][1], rotationX[lo][2], rotationX[lo][3], rotationX[lo][4], delta)

			local rotationY = animationData.curves.rotation_eulerY
			local delta, lo, hi = lookup(rotationY, animTime * hudMotionSpeed)
			local rotationYRes = cubicBezier2D(rotationY[lo][1], rotationY[lo][2], rotationY[lo][3], rotationY[lo][4], delta)

			local rotationZ = animationData.curves.rotation_eulerZ
			local delta, lo, hi = lookup(rotationZ, animTime * hudMotionSpeed)
			local rotationZRes = cubicBezier2D(rotationZ[lo][1], rotationZ[lo][2], rotationZ[lo][3], rotationZ[lo][4], delta)

			local cameraPos = vector():set(
				startCameraPos.x + locationXRes.y,
				startCameraPos.y + locationYRes.y,
				startCameraPos.z + locationZRes.y
			)

			-- Calculate procedural camera transform
			k = normalize(time_global(), startTime, endTime)
			k = math.min(1, k)
			local cameraPos2 = cubicBezier(p1, p2, p3, p4, drf.CubicEaseInOut(k))

			-- Interpolate between procedural and animation camera in animInTime
			local animInK = math.min(1, normalize(animTime, 0, animInTime))
			animInK = drf.QuadraticEaseInOut(animInK)
			local resultPosition = vecLerp(cameraPos2, cameraPos, animInK)
			
			-- Move player with camera then stop it to playerPos
			local currentPlayerPos = vecLerp(
				vector():set(
					resultPosition.x,
					resultPosition.y - camY,
					resultPosition.z
				):sub(animInCameraOffset),
				playerPos,
				animInK
			)					

			-- Calculate position when returning from animation to procedural 
			local animOutK = clamp(normalize(animTime, animOutTime, animationEndTime), 0, 1)
			animOutK = drf.QuadraticEaseInOut(animOutK)
			resultPosition = vecLerp(
				resultPosition,
				cameraPos2,
				animOutK
			)

			-- print_tip(" locationXRes: %s \\n locationYRes: %s \\n locationZRes: %s \\n delta %s \\n lo %s \\n hi %s \\n animInK %s \\n animOutK %s \\n animTime %s", locationXRes, locationYRes, locationZRes, animDelta, animLo, animHi, animInK, animOutK, animTime)

			-- Calculate rotations
			-- Interpolate look to grab point
			local dirFromActorPosToGrabPos = vector():set(
				interPos.x - resultPosition.x,
				climbPos.y - resultPosition.y,
				interPos.z - resultPosition.z
			):normalize()
			dirFromActorPosToGrabPos = vector():set(
				camDirHPB.x,
				dirFromActorPosToGrabPos:getP(),
				0
			)
			local cameraRot = vecLerp(
				camDirHPB,
				dirFromActorPosToGrabPos,
				animInK
			)

			local animRotationK = clamp(normalize(animTime, animInTime, animOutTime), 0, 1)
			animRotationK = drf.QuadraticEaseInOut(animRotationK)

			-- Interpolate look to climbPos
			local dirFromActorPosToClimbPos = vector():set(
				climbPos.x - resultPosition.x,
				climbPos.y - resultPosition.y,
				climbPos.z - resultPosition.z
			):normalize()
			dirFromActorPosToClimbPos = vector():set(
				camDirHPB.x,
				dirFromActorPosToClimbPos:getP() / 4,
				0
			)
			cameraRot = vecLerp(
				cameraRot,
				dirFromActorPosToClimbPos,
				animRotationK
			)

			-- Apply additive from prebaked animation
			cameraRot = vector():set(
				cameraRot.x + rotationXRes.y * getRotationAnimModifier(),
				cameraRot.y + rotationYRes.y * getRotationAnimModifier(),
				cameraRot.z + rotationZRes.y * getRotationAnimModifier()
			)

			-- Return to initial rotation when returning from animation to procedural
			cameraRot = vecLerp(
				cameraRot,
				vector():set(
					camDirHPB.x,
					0,
					0
				),
				animOutK
			)

			db.actor:set_actor_position(currentPlayerPos, true)
			db.actor:set_actor_direction(-camDirHPB.x)
			level.set_cam_custom_position_direction(resultPosition, cameraRot, 1, true, false)

			-- Start hud motion on next tick
			if not hudMotionStarted then
				hudMotionStarted = true
				nextTick(function()
					game.play_hud_motion(2, "item_anm_ledge_grabbing", "anm_climb", true, animationSpeed * hudMotionSpeed)
					return true
				end)
			end

			-- Drain stamina
			local staminaK = drf.QuadraticEaseIn(k) + 1
			db.actor:change_power(-staminaDrainPerMs * staminaK * device().time_delta)

			-- Drain satiety
			local satietyK = k + 1
			db.actor:change_satiety(-satietyDrainPerMs * satietyK * device().time_delta)
		end

		RegisterScriptCallback("actor_on_update", performClimb)
		return true
	end, 2)
	return true
end

function onScreenCheck()
	if not savedClimbPos then return end
	if not savedInterPos then return end

	-- Don't init climb if points arent on the screen
    local climbPosUi = game.world2ui(savedClimbPos)
    local interPosUi = game.world2ui(savedInterPos)
    local topBorder = 768 * 1/3
    local bottomBorder = 768 * 2/3
    local leftBorder = 1024 * 1/3
    local rightBorder = 1024 * 2/3

    if (climbPosUi.x >= leftBorder and climbPosUi.x <= rightBorder and climbPosUi.y >= topBorder and climbPosUi.y <= bottomBorder)
    or (interPosUi.x >= leftBorder and interPosUi.y <= rightBorder and interPosUi.y >= topBorder and interPosUi.y <= bottomBorder)
    then
    	return true
    end
    return false
end

function checkJump(pressed)
	if pressed == true then
		-- If savedClimbPos is similar to camera height or below it - init climb immediately
		if savedClimbPos and (savedClimbPos.y < device().cam_pos.y or similar(savedClimbPos.y, device().cam_pos.y, 0.35)) then
			if tryToClimb() then
				UnregisterScriptCallback("actor_on_update", checkJump)
			end
		elseif savedClimbPos and onScreenCheck() then
	    	if tryToClimb() then
				UnregisterScriptCallback("actor_on_update", checkJump)
			end
		end
	elseif key_state(DIK_keys.DIK_SPACE) == 1 then
		-- Otherwise try after sometime
		if (time_global() - savedJumpPressedTime)  > settings.jumpTriggerTime then
			if savedSpeed.y > -0.003 then
				if tryToClimb() then
					UnregisterScriptCallback("actor_on_update", checkJump)
					return
				end
			else
				-- print_tip("Not jumping stop check, %s", savedSpeed)
				UnregisterScriptCallback("actor_on_update", checkJump)
				return
			end
		end
	else
		UnregisterScriptCallback("actor_on_update", checkJump)
	end
end

function on_key_press(dik)
	if dik == DIK_keys.DIK_H then
		-- tryToClimb()
	end
	if dik == DIK_keys.DIK_J then
		-- debugMode = not debugMode
		-- if not debugMode then
		-- 	reset(nil, true)
		-- end
	end
	local bind = dik_to_bind(dik)
	if bind == key_bindings.kJUMP then
		savedJumpPressedTime = time_global()
		checkJump(true)
		RegisterScriptCallback("actor_on_update", checkJump)
	end
end

function on_game_start()
	assert(level.set_cam_custom_position_direction, "[Ledge Grabbing] Modded Exes are required for mod to work, download from https://github.com/themrdemonized/STALKER-Anomaly-modded-exes")
	RegisterScriptCallback("on_key_press", on_key_press)
	RegisterScriptCallback("on_loading_screen_key_prompt", actor_on_first_update)
	RegisterScriptCallback("actor_on_first_update", load_settings)
	RegisterScriptCallback("on_option_change", load_settings)
end
